<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DQI・Ⅱダメージ計算</title>
  <link rel="stylesheet" href="theme.css" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    .card { border: 1px solid rgba(255,255,255,.12); border-radius: 12px; padding: 14px; margin: 12px 0; background: rgba(0,0,0,.12); }
    .row { display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px; }
    .col-12{grid-column: span 12;}
    .col-6{grid-column: span 6;}
    .col-4{grid-column: span 4;}
    .col-3{grid-column: span 3;}
    .col-2{grid-column: span 2;}
    label { display:block; font-size: 13px; opacity:.9; margin-bottom:6px; }
    input, select, button { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.18); background: rgba(0,0,0,.2); color: inherit; }
    input[type="checkbox"]{ width:auto; }
    button { cursor: pointer; }
    .muted { opacity: .75; font-size: 13px; }
    .pill { display:inline-block; padding: 4px 10px; border: 1px solid rgba(255,255,255,.18); border-radius: 999px; font-size: 12px; opacity:.9; }
    .out { font-size: 20px; font-weight: 700; }
    .out small{ font-size: 13px; font-weight: 500; opacity:.8; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid rgba(255,255,255,.12); padding: 8px; font-size: 13px; text-align:left; vertical-align: top; }
    .btn-row{ display:flex; gap:6px; margin-top:6px; }
    .btn-mini{ width:auto; padding:6px 10px; border-radius:999px; font-size:12px; }
    .actions { display:flex; gap: 8px; flex-wrap: wrap; }
    .actions button { width: auto; }
    .right { text-align:right; }
  </style>
</head>
<body>
  <main class="wrap page-main">
    <h1>DQI・Ⅱダメージ計算</h1>
<section class="card">
      <h2 style="margin:0 0 10px 0;font-size:16px;">入力</h2>

      <div class="row">
        <div class="col-3">
          <label>作品</label>
          <select id="game">
            <option value="DQ1">DQ1</option>
            <option value="DQ2">DQ2</option>
          </select>
        </div>

        <div class="col-3">
          <label>ゲームモード</label>
          <select id="mode">
            <option value="バッチリぼうけん">バッチリぼうけん</option>
            <option value="楽ちんプレイ">楽ちんプレイ</option>
          </select>
          

        </div>

        <div class="col-3">
          <label>敵（任意）</label>
          <select id="enemy">
            <option value="">（未選択）</option>
          </select>
          

        </div>

        <div class="col-3">
          <label>敵の防御</label>
          <input id="def" type="number" inputmode="numeric" placeholder="例：499" />
        </div>

        <div class="col-3">
          <label>キャラ（任意）</label>
          <select id="chara">
            <option value="">（未選択）</option>
            <option value="DQ1主人公">DQ1主人公</option>
            <option value="DQ2ローレシア王子">DQ2ローレシア王子</option>
            <option value="DQ2サマルトリア王子">DQ2サマルトリア王子</option>
            <option value="DQ2ムーンブルク王女">DQ2ムーンブルク王女</option>
            <option value="DQ2サマルトリア王女">DQ2サマルトリア王女</option>
          </select>
          

        </div>

        <div class="col-2">
          <label>LV</label>
          <input id="lv" type="number" inputmode="numeric" placeholder="例：40" />
        </div>

        <div class="col-2">
          <label>運の良さ</label>
          <input id="luck" type="number" inputmode="numeric" placeholder="例：55" />
        </div>

        <div class="col-2">
          <label>運基準</label>
          <select id="luckBand">
            <option value="auto">自動</option>
            <option value="最小">最小</option>
            <option value="中">中</option>
            <option value="最大">最大</option>
          </select>
          

        </div>

        <div class="col-3">
          <label>攻撃</label>
          <input id="atk" type="number" inputmode="numeric" placeholder="例：384" />
        </div>

        <div class="col-3">
          <label>技（任意）</label>
          <select id="skill">
            <option value="" data-mult="1">通常攻撃（倍率1.0）</option>
          </select>
          

        </div>

        <div class="col-2">
          <label>技倍率</label>
          
          <input id="skillMult" type="number" step="0.001" inputmode="decimal" placeholder="例：1.6" value="1" />
          <div class="btn-row">
            <button type="button" class="btn-mini" id="setSkillNormal">通常(1.1)</button>
            <button type="button" class="btn-mini" id="setSkillEffective">特効(1.6)</button>
          </div>

        </div>

        <div class="col-2">
          <label>バイキルト</label>
          <label style="display:flex;align-items:center;gap:8px;margin:0;padding:10px;border:1px solid rgba(255,255,255,.18);border-radius:10px;background:rgba(0,0,0,.2);">
            <input id="bikilt" type="checkbox" />
            有効（2倍）
          </label>
        </div>

        <div class="col-4">
          <label>ちからため / 超ちからため / おうえん</label>
          <select id="tame">
            <option value="none">なし</option>
            <option value="tame">ちからため（2倍）</option>
            <option value="super_tame">超ちからため（3倍）</option>
            <option value="ouen">おうえん（2倍）</option>
          </select>
          

        </div>

        <div class="col-2">
          <label>手動倍率（任意）</label>
          <input id="manualMult" type="number" step="0.001" inputmode="decimal" placeholder="例：1.2" value="1" />
        </div>

        <div class="col-4">
          <label>ルカニ/スカラ段階（-6〜+6）</label>
          <select id="defStage"></select>
          

        </div>

        <div class="col-2" style="display:flex;align-items:end;gap:10px;">
          <label style="margin:0;">
            <input id="stageUnknown" type="checkbox" />
            段階不明（1/3/6表示）
          </label>
        </div>
      </div>

      <div class="actions" style="margin-top:12px;">
        <button id="btnCalc">計算してログに追加</button>
        <button id="btnClear" type="button">ログ全消し</button>
        <button id="btnCsv" type="button">ログをCSVでDL</button>
      </div>
    </section>

    <section class="card">
      <h2 style="margin:0 0 10px 0;font-size:16px;">結果</h2>

      <div id="resultMain" class="out">-</div>
      <div class="muted" id="resultSub">-</div>

      <div id="resultBands" style="margin-top:10px;"></div>
    </section>

    <section class="card">
      <h2 style="margin:0 0 10px 0;font-size:16px;">ログ一覧</h2>
      

      <div style="overflow:auto;margin-top:10px;">
        <table id="logTable">
          <thead>
            <tr>
              <th>#</th>
              <th>作品</th>
              <th>敵</th>
              <th class="right">攻撃</th>
              <th class="right">防御</th>
              <th>運基準</th>
              <th>モード</th>
              <th>技</th>
              <th class="right">倍率</th>
              <th class="right">平均</th>
              <th class="right">最小〜最大</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
</main>

<script>
(() => {
  function $(id){ return document.getElementById(id); }
  function safeNumber(v, fallback=null){
    if (v === null || v === undefined) return fallback;
    if (typeof v === "string" && v.trim() === "") return fallback;
    const n = Number(v);
    return Number.isFinite(n) ? n : fallback;
  }
  function roundDown(n){ return Math.floor(n); }
  function fmt(n, digits=3){ if (!Number.isFinite(n)) return "-"; return n.toFixed(digits).replace(/\.?0+$/, ""); }

  function parseCSV(text) {
    if (!text) return [];
    if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
    const rows = [];
    let row = [], field = "", inQuotes = false;
    for (let i = 0; i < text.length; i++) {
      const c = text[i];
      if (inQuotes) {
        if (c === '"') {
          if (text[i+1] === '"') { field += '"'; i++; }
          else { inQuotes = false; }
        } else field += c;
      } else {
        if (c === '"') inQuotes = true;
        else if (c === ",") { row.push(field); field = ""; }
        else if (c === "\n" || c === "\r") {
          if (c === "\r" && text[i+1] === "\n") i++;
          row.push(field);
          if (row.length > 1 || row[0] !== "") rows.push(row);
          row = []; field = "";
        } else field += c;
      }
    }
    row.push(field);
    if (row.length > 1 || row[0] !== "") rows.push(row);
    if (!rows.length) return [];
    const headers = rows[0].map(h => (h || "").trim());
    const out = [];
    for (let r = 1; r < rows.length; r++) {
      const obj = {};
      for (let c = 0; c < headers.length; c++) obj[headers[c]] = (rows[r][c] ?? "").trim();
      out.push(obj);
    }
    return out;
  }

  async function fetchText(url){
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("fetch失敗: " + url);
    return await res.text();
  }

  // 同一オリジンの公開HTML（CSV読込＋描画後のテーブル）を確実に拾うためのヘルパー
  async function withIframe(url, tryExtract, timeoutMs=12000, intervalMs=150){
    return new Promise((resolve) => {
      const iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.src = url;
      document.body.appendChild(iframe);

      const start = Date.now();
      let done = false;
      const cleanup = () => { try{ iframe.remove(); }catch(e){} };

      const tick = () => {
        if (done) return;
        const doc = iframe.contentDocument;
        let val = null;
        try{ val = doc ? tryExtract(doc) : null; }catch(e){ val = null; }
        if (val){
          done = true; cleanup(); resolve(val); return;
        }
        if (Date.now() - start > timeoutMs){
          done = true; cleanup(); resolve(null); return;
        }
        setTimeout(tick, intervalMs);
      };

      iframe.addEventListener("load", () => setTimeout(tick, intervalMs));
      iframe.addEventListener("error", () => { done = true; cleanup(); resolve(null); });
    });
  }

  function parseNums(text){
    const s = String(text ?? "").replace(/,/g," ");
    const m = s.match(/\d+(?:\.\d+)?/g);
    return m ? m.map(Number).filter(n=>Number.isFinite(n)) : [];
  }

  function getHeaders(table){
    const headRow = table.querySelector("thead tr") || table.querySelector("tr");
    if (!headRow) return [];
    return Array.from(headRow.children).map(c => (c.textContent || "").trim());
  }

  function rowsOf(table){
    const body = table.querySelector("tbody");
    const trs = body ? Array.from(body.querySelectorAll("tr")) : Array.from(table.querySelectorAll("tr")).slice(1);
    return trs;
  }

  function findTable(doc, needHeaders){
    const tables = Array.from(doc.querySelectorAll("table"));
    for (const t of tables){
      const headers = getHeaders(t);
      if (!headers.length) continue;
      const ok = needHeaders.every(h => headers.some(x => x.includes(h)));
      if (ok) return t;
    }
    return null;
  }

  function extractSkillList(doc){
    // 「倍率」列がある表を対象にする（名前列は「名前/名称/技」など）
    const tables = Array.from(doc.querySelectorAll("table"));
    const out = [];
    for (const t of tables){
      const headers = getHeaders(t);
      if (!headers.length) continue;
      const idxMult = headers.findIndex(h => h.includes("倍率"));
      const idxName = headers.findIndex(h => h.includes("名前") || h.includes("名称") || h.includes("技"));
      if (idxMult < 0 || idxName < 0) continue;

      const idxType = headers.findIndex(h => h.includes("種別") || h.includes("分類") || h.includes("タイプ"));
      for (const tr of rowsOf(t)){
        const cells = Array.from(tr.children);
        const name = (cells[idxName]?.textContent || "").trim();
        if (!name) continue;
        const nums = parseNums(cells[idxMult]?.textContent || "");
        if (!nums.length) continue;

        const type = idxType >= 0 ? (cells[idxType]?.textContent || "").trim() : "";
        const normal = nums[0];
        const eff = nums.length >= 2 ? nums[1] : null;
        out.push({ name, type, mult: normal, multEff: eff });
      }
      if (out.length) break; // 最初に見つかった有効テーブルを優先
    }
    return out.length ? out : null;
  }

  function extractBossOrder(doc){
    // ボス一覧は「名前」列がある表を優先。無ければリンク順。
    const tables = Array.from(doc.querySelectorAll("table"));
    for (const t of tables){
      const headers = getHeaders(t);
      if (!headers.length) continue;
      const idxName = headers.findIndex(h => h.includes("ボス") || h.includes("敵") || h.includes("名前") || h.includes("名称"));
      if (idxName < 0) continue;

      const idxDef = headers.findIndex(h => h.includes("守備") || h.includes("防御"));
      const list = [];
      for (const tr of rowsOf(t)){
        const cells = Array.from(tr.children);
        const name = (cells[idxName]?.textContent || "").trim();
        if (!name) continue;
        const defNums = idxDef >= 0 ? parseNums(cells[idxDef]?.textContent || "") : [];
        const def = defNums.length ? defNums[0] : null;
        list.push({ name, def });
      }
      if (list.length) return list;
    }
    // fallback: リンク順（ボスっぽいリンクだけ）
    const list = [];
    for (const a of Array.from(doc.querySelectorAll("a"))){
      const href = (a.getAttribute("href") || "").trim();
      if (!href) continue;
      if (!/boss/i.test(href) || !href.endsWith(".html")) continue;
      const name = (a.textContent || "").trim();
      if (!name) continue;
      list.push({ name, def: null });
    }
    return list.length ? list : null;
  }

  function extractBossDefenseMap(doc){
    // DB側にボス防御が載ってる表があれば拾う
    const tables = Array.from(doc.querySelectorAll("table"));
    const map = {};
    for (const t of tables){
      const headers = getHeaders(t);
      if (!headers.length) continue;
      const idxName = headers.findIndex(h => h.includes("ボス") || h.includes("敵") || h.includes("名前") || h.includes("名称"));
      const idxDef = headers.findIndex(h => h.includes("守備") || h.includes("防御"));
      if (idxName < 0 || idxDef < 0) continue;

      for (const tr of rowsOf(t)){
        const cells = Array.from(tr.children);
        const name = (cells[idxName]?.textContent || "").trim();
        if (!name) continue;
        const defNums = parseNums(cells[idxDef]?.textContent || "");
        if (!defNums.length) continue;
        map[name] = defNums[0];
      }
      if (Object.keys(map).length) return map;
    }
    return null;
  }

  const DEFAULT_CONFIG_URL = "dq_damage_calc_private.json";
  const BUILTIN_CONFIG = {
    version: 1,
    base_state: { luck_ref: "最大", mode_ref: "バッチリぼうけん" },
    random_range: { min: 0.90, max: 1.10 },
    modes: { "バッチリぼうけん": 1.0, "楽ちんプレイ": 1.2 },

    luck_multipliers: {
      DQ1: { "最小": 0.753404, "中": 0.856676, "最大": 1.0 },
      DQ2: { "最小": 0.660913083635202, "中": 0.83753922756278, "最大": 1.0 }
    },
    def_stage_multipliers: { down: { "1": 1.270721206, "3": 1.433799785, "6": 1.804518211 }, up: {} },
    buffs: { bikilt: { label: "バイキルト", mult: 2.0 }, tame: { label: "ちからため", mult: 2.0 }, super_tame: { label: "超ちからため", mult: 3.0 }, ouen: { label: "おうえん", mult: 2.0 } },
    games: {
      DQ1: { formula_terms: [ { name: "atk", coef: 0.749991892417 }, { name: "def", coef: -0.264610864087 }, { name: "atk2", coef: -0.000498335818083 } ] },
      DQ2: { formula_terms: [ { name: "atk", coef: 0.971654263609 }, { name: "def", coef: -0.387760162756 }, { name: "atk_def", coef: -0.00113383813267 }, { name: "def2", coef: 0.00055735581224 } ] }
    }
  };

  let CFG = structuredClone(BUILTIN_CONFIG);
  async function loadConfig(){
    try{
      const txt = await fetchText(DEFAULT_CONFIG_URL);
      const obj = JSON.parse(txt);
      if (obj && obj.games) CFG = obj;
    }catch(e){}
  }

  const SRC = {
    abilityCsv: "dq_data_ability.csv",
    bossList: { DQ1: "dq1_boss_list.html", DQ2: "dq2_boss_list.html" },
    db: { DQ1: "dq1_db.html", DQ2: "dq2_db.html" },
    characterIndex: "dq_character.html"
  };

  let abilityRows = [];
  let skillMap = { DQ1: [], DQ2: [] };
  let enemyMap = { DQ1: [], DQ2: [] };
  let luckThresholds = {};

  function normalizeKey(s){ return (s || "").trim(); }

  function buildLuckThresholds(){
    const out = {};
    abilityRows.forEach(r => {
      const char = normalizeKey(r["キャラ名"]);
      const lv = normalizeKey(r["レベル"]);
      if (!char || !lv) return;
      out[char] ||= {};
      out[char][lv] = { low: safeNumber(r["運下限"], null), high: safeNumber(r["運上限"], null) };
    });
    luckThresholds = out;
  }

  function autoLuckBand(charName, lv, luckValue){
    const c = normalizeKey(charName);
    const L = String(lv ?? "").trim();
    const luck = safeNumber(luckValue, null);
    const t = luckThresholds?.[c]?.[L];
    if (!t || t.low == null || t.high == null || luck == null) return null;
    if (luck < t.low) return "最小";
    if (luck <= t.high) return "中";
    return "最大";
  }

  function pickMultiplier(map, key, fallback=1.0){
    const v = map?.[key];
    return Number.isFinite(v) ? v : fallback;
  }

  function interpolateStageTable(down, up){
    function buildSide(src){
      const known = Object.entries(src || {}).map(([k,v]) => [Number(k), Number(v)]).filter(([k,v]) => Number.isFinite(k) && Number.isFinite(v));
      known.sort((a,b)=>a[0]-b[0]);
      const arr = Array(7).fill(null);
      arr[0] = 1.0;
      known.forEach(([k,v]) => { if (k>=1 && k<=6) arr[k] = v; });
      for (let i=1;i<=6;i++){
        if (arr[i]!=null) continue;
        let l=i-1; while(l>=0 && arr[l]==null) l--;
        let r=i+1; while(r<=6 && arr[r]==null) r++;
        if (l>=0 && r<=6 && arr[l]!=null && arr[r]!=null){
          const t = (i-l)/(r-l);
          arr[i] = arr[l] + (arr[r]-arr[l])*t;
        } else if (l>=0 && arr[l]!=null) arr[i] = arr[l];
        else if (r<=6 && arr[r]!=null) arr[i] = arr[r];
        else arr[i] = 1.0;
      }
      return arr;
    }
    const downArr = buildSide(down);
    const hasUp = up && Object.keys(up).length;
    const upArr = hasUp ? buildSide(up) : downArr.map((v,i)=> i===0 ? 1.0 : (v ? (1.0/v) : 1.0));
    return { downArr, upArr };
  }

  function stageMultiplier(stage){
    const s = Number(stage);
    if (!Number.isFinite(s) || s===0) return 1.0;
    const { downArr, upArr } = interpolateStageTable(CFG.def_stage_multipliers?.down, CFG.def_stage_multipliers?.up);
    const k = Math.min(6, Math.max(1, Math.abs(s)));
    return (s < 0) ? downArr[k] : upArr[k];
  }

  function baseDamage(game, atk, def){
    const g = CFG.games?.[game];
    if (!g) return null;
    let sum = 0;
    for (const t of (g.formula_terms || [])){
      const coef = Number(t.coef);
      if (!Number.isFinite(coef)) continue;
      let x = 0;
      switch(String(t.name)){
        case "atk": x = atk; break;
        case "def": x = def; break;
        case "atk2": x = atk*atk; break;
        case "def2": x = def*def; break;
        case "atk_def": x = atk*def; break;
        default: x = 0; break;
      }
      sum += coef * x;
    }
    return sum;
  }

  function totalMultiplier(params){
    const { game, mode, luckBand, skillMult, bikiltOn, tameKey, manualMult, defStage } = params;
    const modeMult = pickMultiplier(CFG.modes, mode, 1.0);
    const luckMult = pickMultiplier(CFG.luck_multipliers?.[game], luckBand, 1.0);
    const sk = safeNumber(skillMult, 1.0) ?? 1.0;
    let buffMult = 1.0;
    // バイキルトは併用可（2倍）
    if (bikiltOn) buffMult *= (safeNumber(CFG.buffs?.bikilt?.mult, 2.0) ?? 2.0);
    // ため系はどれか1つ
    if (tameKey && tameKey !== "none") buffMult *= (safeNumber(CFG.buffs?.[tameKey]?.mult, 1.0) ?? 1.0);
    const man = safeNumber(manualMult, 1.0) ?? 1.0;
    const stageMult = stageMultiplier(defStage);
    return modeMult * luckMult * sk * buffMult * man * stageMult;
  }

  function initStageSelect(){
    const sel = $("defStage");
    sel.innerHTML = "";
    for (let s=-6; s<=6; s++){
      const op = document.createElement("option");
      op.value = String(s);
      op.textContent = (s===0) ? "0（変化なし）" : (s<0 ? `防御↓ ${Math.abs(s)}段階` : `防御↑ ${s}段階`);
      sel.appendChild(op);
    }
    sel.value = "0";
  }

  const logs = [];
  function renderLogs(){
    const tbody = $("logTable").querySelector("tbody");
    tbody.innerHTML = "";
    logs.forEach((r, idx) => {
      const tr = document.createElement("tr");
      const cells = [ String(idx+1), r.game, r.enemy || "-", r.atk, r.def, r.luckBand, r.mode, r.skill || "通常", fmt(r.mult,3), r.mean, r.min + "〜" + r.max ];
      cells.forEach((v,i)=>{
        const td = document.createElement("td");
        td.textContent = String(v);
        if ([3,4,8,9,10].includes(i)) td.className="right";
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
  }

  function setResultMain(mean, min, max){
    $("resultMain").innerHTML = `${mean} <small>（最小〜最大: ${min}〜${max}）</small>`;
  }
  function setResultSub(text){ $("resultSub").textContent = text; }

  function setBandCards(items){
    const wrap = $("resultBands");
    wrap.innerHTML = "";
    if (!items || !items.length) return;
    const row = document.createElement("div");
    row.className = "row";
    items.forEach(it => {
      const div = document.createElement("div");
      div.className = "col-4";
      div.innerHTML = `<div class="card" style="margin:0;">
        <div class="pill">${it.label}</div>
        <div class="out" style="margin-top:8px;">${it.mean} <small>（${it.min}〜${it.max}）</small></div>
        

      </div>`;
      row.appendChild(div);
    });
    wrap.appendChild(row);
  }

  function currentLuckBand(){
    const sel = $("luckBand").value;
    if (sel !== "auto") return sel;
    const chara = $("chara").value;
    const lv = safeNumber($("lv").value, null);
    const luck = safeNumber($("luck").value, null);
    const auto = autoLuckBand(chara, lv, luck);
    return auto || "最大";
  }

  function updateLuckAutoLabel(){
    const chara = $("chara").value;
    const lv = safeNumber($("lv").value, null);
    const luck = safeNumber($("luck").value, null);
    const auto = autoLuckBand(chara, lv, luck);
    const sel = $("luckBand");
    const opt = Array.from(sel.options).find(o => o.value === "auto");
    if (opt){
      opt.textContent = auto ? `自動（${auto}）` : "自動";
    }
  }

  function computeOnce(forcedStage=null){
    const game = $("game").value;
    const mode = $("mode").value;
    const enemy = $("enemy").value;
    const atk = safeNumber($("atk").value, null);
    const def = safeNumber($("def").value, null);
    const skill = $("skill").value;
    const skillMult = safeNumber($("skillMult").value, 1.0) ?? 1.0;
    const bikiltOn = $("bikilt").checked;
    const tameKey = $("tame").value;
    const manualMult = safeNumber($("manualMult").value, 1.0) ?? 1.0;
    const defStage = forcedStage != null ? forcedStage : safeNumber($("defStage").value, 0) ?? 0;
    const luckBand = currentLuckBand();
    if (atk == null || def == null) return { error: "攻撃・防御を入力してください。" };
    const base = baseDamage(game, atk, def);
    if (base == null) return { error: "設定が読み込めませんでした。" };
    const mult = totalMultiplier({ game, mode, luckBand, skillMult, bikiltOn, tameKey, manualMult, defStage });
    const rr = CFG.random_range || {min:0.9,max:1.1};
    const mean = base * mult;
    const mn = mean * (safeNumber(rr.min,0.9) ?? 0.9);
    const mx = mean * (safeNumber(rr.max,1.1) ?? 1.1);
    return { game, mode, enemy, atk, def, luckBand, skill, mult, mean: roundDown(mean), min: roundDown(mn), max: roundDown(mx) };
  }

  function applyResult(){
    const unknown = $("stageUnknown").checked;
    if (!unknown){
      const r = computeOnce();
      if (r.error){ setResultMain("-", "-", "-"); setResultSub(r.error); setBandCards([]); return; }
      setResultMain(r.mean, r.min, r.max);
      const stage = safeNumber($("defStage").value, 0) ?? 0;
      const stageText = (stage===0) ? "0" : (stage<0 ? `防御↓${Math.abs(stage)}` : `防御↑${stage}`);
      setResultSub(`倍率合計: ${fmt(r.mult,3)} / 段階: ${stageText}`);
      setBandCards([]);
      return;
    }
    const stages = [-1, -3, -6, 1, 3, 6];
    const items = [];
    for (const s of stages){
      const r = computeOnce(s);
      if (r.error) continue;
      items.push({ label: s<0 ? `防御↓${Math.abs(s)}段階` : `防御↑${s}段階`, mean: r.mean, min: r.min, max: r.max, stageText: s<0 ? `↓${Math.abs(s)}` : `↑${s}` });
    }
    if (!items.length){ setResultMain("-", "-", "-"); setResultSub("攻撃・防御を入力してください。"); setBandCards([]); return; }
    const pick = items.find(x => x.label.includes("↓3")) || items[0];
    setResultMain(pick.mean, pick.min, pick.max);
    setResultSub("");
    setBandCards(items);
  }

  function addLog(){
    const unknown = $("stageUnknown").checked;
    if (unknown){
      const stages = [-1, -3, -6, 1, 3, 6];
      for (const s of stages){
        const r = computeOnce(s);
        if (r.error) continue;
        logs.push({ game: r.game, enemy: r.enemy, atk: r.atk, def: r.def, luckBand: r.luckBand, mode: r.mode, skill: r.skill, mult: r.mult, mean: r.mean, min: r.min, max: r.max });
      }
      renderLogs(); return;
    }
    const r = computeOnce();
    if (r.error){ setResultSub(r.error); return; }
    logs.push({ game: r.game, enemy: r.enemy, atk: r.atk, def: r.def, luckBand: r.luckBand, mode: r.mode, skill: r.skill, mult: r.mult, mean: r.mean, min: r.min, max: r.max });
    renderLogs();
  }

  function downloadCsv(){
    if (!logs.length){ alert("ログが空です。"); return; }
    const headers = ["作品","敵","攻撃","防御","運基準","モード","技","倍率合計","平均","最小","最大"];
    const lines = [headers.join(",")];
    logs.forEach(r=>{
      const row = [r.game, r.enemy||"", r.atk, r.def, r.luckBand, r.mode, r.skill||"", fmt(r.mult,6), r.mean, r.min, r.max]
        .map(v => `"${String(v).replaceAll('"','""')}"`);
      lines.push(row.join(","));
    });
    const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "dq_damage_calc_log.csv";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function clearOptions(sel, keepFirst=true){
    while (sel.options.length > (keepFirst?1:0)) sel.remove(sel.options.length-1);
  }

  function guessDefenseField(obj){
    const keys = Object.keys(obj||{});
    const candidates = ["防御","防御力","守備","守備力","DEF","Def","def","守備値"];
    for (const c of candidates){ const k = keys.find(k => k.trim() === c); if (k) return k; }
    return keys.find(k => k.includes("防") || k.includes("守")) || null;
  }

  function guessNameField(obj){
    const keys = Object.keys(obj||{});
    const candidates = ["名前","敵名","敵","ボス名","モンスター名","ユニット名","名称"];
    for (const c of candidates){ const k = keys.find(k => k.trim() === c); if (k) return k; }
    return keys[0] || null;
  }

  async function loadAbility(){
    try{
      const txt = await fetchText(SRC.abilityCsv);
      abilityRows = parseCSV(txt);
      buildLuckThresholds();
    }catch(e){ abilityRows = []; luckThresholds = {}; }
  }

  async function loadSkills(game){
    try{
      const list = await withIframe(SRC.db[game], (doc) => extractSkillList(doc));
      const out = list || [];
      // 先頭に通常攻撃
      skillMap[game] = [{ name:"通常攻撃", type:"", mult:1.0, multEff:null }, ...out];
    }catch(e){
      skillMap[game] = [{ name:"通常攻撃", type:"", mult:1.0, multEff:null }];
    }
  }
);
      const typeRank = (t) => (t === "特技") ? 0 : (t === "超絶技") ? 1 : (t === "呪文") ? 2 : 9;
      out.sort((a,b)=>{ const ra=typeRank(a.type), rb=typeRank(b.type); if (ra!==rb) return ra-rb; return a.name.localeCompare(b.name,"ja"); });
      skillMap[game] = out;
    }catch(e){ skillMap[game] = []; }
  }

  async function loadEnemies(game){
    try{
      const defMap = await withIframe(SRC.db[game], (doc) => extractBossDefenseMap(doc)) || {};
      const ordered = await withIframe(SRC.bossList[game], (doc) => extractBossOrder(doc)) || [];
      const seen = new Set();
      const out = [];
      for (const it of ordered){
        const name = String(it.name || "").trim();
        if (!name || seen.has(name)) continue;
        seen.add(name);
        const def = Number.isFinite(it.def) ? it.def : (Number.isFinite(defMap[name]) ? defMap[name] : null);
        out.push({ name, def });
      }
      enemyMap[game] = out;
    }catch(e){
      enemyMap[game] = [];
    }
  }


  function refreshEnemySelect(){
    const game = $("game").value;
    const sel = $("enemy");
    clearOptions(sel, true);
    enemyMap[game].forEach(it=>{
      const op = document.createElement("option");
      op.value = it.name;
      op.textContent = it.name + (Number.isFinite(it.def) ? `（防御${it.def}）` : "");
      op.dataset.def = Number.isFinite(it.def) ? String(it.def) : "";
      sel.appendChild(op);
    });
  }

  function refreshSkillSelect(){
    const game = $("game").value;
    const sel = $("skill");
    clearOptions(sel, true);
    (skillMap[game] || []).forEach(it=>{
      const op = document.createElement("option");
      op.value = it.name;
      const hasEff = Number.isFinite(it.multEff) && it.multEff !== null && Math.abs(it.multEff - it.mult) > 1e-9;
      op.textContent = hasEff
        ? `${it.name}（通常${fmt(it.mult,3)} / 特効${fmt(it.multEff,3)}）`
        : `${it.name}（倍率${fmt(it.mult,3)}）`;
      op.dataset.mult = String(it.mult);
      op.dataset.multEff = hasEff ? String(it.multEff) : "";
      sel.appendChild(op);
    });
  });
  }

  function bind(){
    $("btnCalc").addEventListener("click", () => { addLog(); applyResult(); });
    $("btnClear").addEventListener("click", () => { logs.length=0; renderLogs(); applyResult(); });
    $("btnCsv").addEventListener("click", downloadCsv);
    $("setSkillNormal").addEventListener("click", () => { $("skillMult").value = "1.1"; applyResult(); });
    $("setSkillEffective").addEventListener("click", () => { $("skillMult").value = "1.6"; applyResult(); });

    const ids = ["game","mode","enemy","atk","def","skill","skillMult","bikilt","tame","manualMult","defStage","stageUnknown","chara","lv","luck","luckBand"];
    ids.forEach(id=>{
      $(id).addEventListener("change", () => {
        if (id==="enemy"){
          const sel = $("enemy");
          const op = sel.options[sel.selectedIndex];
          const d = safeNumber(op?.dataset?.def, null);
          if (d != null) $("def").value = String(d);
        }
        if (id==="skill"){
          const sel = $("skill");
          const op = sel.options[sel.selectedIndex];
          const m = safeNumber(op?.dataset?.mult, null);
          if (m != null) $("skillMult").value = String(m);
          else if (!$("skill").value) $("skillMult").value = "1";
        }
        if (id==="game"){ refreshEnemySelect(); refreshSkillSelect(); }
        updateLuckAutoLabel();
        applyResult();
      });
    });
    ["lv","luck","chara"].forEach(id=> $(id).addEventListener("input", () => { updateLuckAutoLabel(); applyResult(); }));
  }

  async function boot(){
    initStageSelect();
    $("mode").value = "バッチリぼうけん";
    // 初期値（空欄→0化防止）
    $("skillMult").value = $("skillMult").value.trim() ? $("skillMult").value : "1";
    $("manualMult").value = $("manualMult").value.trim() ? $("manualMult").value : "1";
    await loadConfig();
    await loadAbility();
    await Promise.all([ loadSkills("DQ1"), loadSkills("DQ2"), loadEnemies("DQ1"), loadEnemies("DQ2") ]);
    refreshEnemySelect();
    refreshSkillSelect();
    updateLuckAutoLabel();
    bind();
    applyResult();
  }

  boot();
})();
</script>
</body>
</html>
